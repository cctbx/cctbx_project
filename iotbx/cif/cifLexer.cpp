/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g
 *     -                            On : 2010-09-29 10:56:09
 *     -                 for the lexer : cifLexerLexer *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "cifLexer.h"
/* ----------------------------------------- */


/** String literals used by cifLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR     lit_1[]  = { 0x0D, 0x0A,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define         CTX     ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define SCOPE_TYPE(scope)   pcifLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcifLexer_##scope##Stack
#define SCOPE_TOP(scope)    ctx->pcifLexer_##scope##Top
#define SCOPE_SIZE(scope)               ctx->pcifLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)        (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef      LEXER
#undef      RECOGNIZER
#undef      RULEMEMO
#undef      GETCHARINDEX
#undef      GETLINE
#undef      GETCHARPOSITIONINLINE
#undef      EMIT
#undef      EMITNEW
#undef      MATCHC
#undef      MATCHS
#undef      MATCHRANGE
#undef      LTOKEN
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      INPUT
#undef      STRSTREAM
#undef      LA
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      LRECOVER
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      BACKTRACKING
#undef          MATCHANY
#undef          MEMOIZE
#undef          HAVEPARSEDRULE
#undef          GETTEXT
#undef          INDEX
#undef          SEEK
#undef          PUSHSTREAM
#undef          POPSTREAM
#undef          SETTEXT
#undef          SETTEXT8

#define     LEXER                                       ctx->pLexer
#define     RECOGNIZER                      LEXER->rec
#define         LEXSTATE                                RECOGNIZER->state
#define         TOKSOURCE                               LEXSTATE->tokSource
#define     GETCHARINDEX()                      LEXER->getCharIndex(LEXER)
#define     GETLINE()                           LEXER->getLine(LEXER)
#define     GETTEXT()                           LEXER->getText(LEXER)
#define     GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define     EMIT()                                      LEXSTATE->type = _type; LEXER->emit(LEXER)
#define     EMITNEW(t)                          LEXER->emitNew(LEXER, t)
#define     MATCHC(c)                           LEXER->matchc(LEXER, c)
#define     MATCHS(s)                           LEXER->matchs(LEXER, s)
#define     MATCHRANGE(c1,c2)       LEXER->matchRange(LEXER, c1, c2)
#define     MATCHANY()                          LEXER->matchAny(LEXER)
#define     LTOKEN                              LEXSTATE->token
#define     HASFAILED()                         (LEXSTATE->failed == ANTLR3_TRUE)
#define     BACKTRACKING                        LEXSTATE->backtracking
#define     FAILEDFLAG                          LEXSTATE->failed
#define     INPUT                                       LEXER->input
#define     STRSTREAM                           INPUT
#define         ISTREAM                                 INPUT->istream
#define         INDEX()                                 ISTREAM->index(ISTREAM)
#define         SEEK(n)                                 ISTREAM->seek(ISTREAM, n)
#define     EOF_TOKEN                           &(LEXSTATE->tokSource->eofToken)
#define     HASEXCEPTION()                      (LEXSTATE->error == ANTLR3_TRUE)
#define     EXCEPTION                           LEXSTATE->exception
#define     CONSTRUCTEX()                       RECOGNIZER->exConstruct(RECOGNIZER)
#define     LRECOVER()                          LEXER->recover(LEXER)
#define     MARK()                                      ISTREAM->mark(ISTREAM)
#define     REWIND(m)                           ISTREAM->rewind(ISTREAM, m)
#define     REWINDLAST()                        ISTREAM->rewindLast(ISTREAM)
#define         MEMOIZE(ri,si)                  RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define         HAVEPARSEDRULE(r)               RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define         PUSHSTREAM(str)                 LEXER->pushCharStream(LEXER, str)
#define         POPSTREAM()                             LEXER->popCharStream(LEXER)
#define         SETTEXT(str)                    LEXSTATE->text = str
#define         SKIP()                                  LEXSTATE->token = &(TOKSOURCE->skipToken)
#define         USER1                                   LEXSTATE->user1
#define         USER2                                   LEXSTATE->user2
#define         USER3                                   LEXSTATE->user3
#define         CUSTOM                                  LEXSTATE->custom
#define         RULEMEMO                                LEXSTATE->ruleMemo
#define         DBG                                             RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if     defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define           NEXTCHAR                    ((pANTLR3_UINT8)(INPUT->nextChar))
#  define           DATAP                               ((pANTLR3_UINT8)(INPUT->data))

# else

#  define           NEXTCHAR                    ((pANTLR3_UINT16)(INPUT->nextChar))
#  define           DATAP                               ((pANTLR3_UINT16)(INPUT->data))

# endif

# define            LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                                                                   \
{                                                                                                                                       \
    if  (NEXTCHAR < (DATAP + INPUT->sizeBuf))                                           \
    {                                                                                                                           \
                INPUT->charPositionInLine++;                                                            \
                if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
                {                                                                                                                       \
                        INPUT->line++;                                                                                  \
                        INPUT->charPositionInLine       = 0;                                            \
                        INPUT->currentLine              = (void *)(NEXTCHAR + 1);               \
                }                                                                                                                       \
                INPUT->nextChar = (void *)(NEXTCHAR + 1);                                       \
    }                                                                                                                           \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define     CONSUME()                           INPUT->istream->consume(INPUT->istream)
#define     LA(n)                                       INPUT->istream->_LA(INPUT->istream, n)

#endif
#define         TOKTEXT(tok, txt)                               tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define     UP      ANTLR3_TOKEN_UP
#define     DOWN    ANTLR3_TOKEN_DOWN
#define     EOR     ANTLR3_TOKEN_EOR
#define     INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void      mT__30    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__31    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__32    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__33    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__34    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__35    (pcifLexer ctx);
static ANTLR3_INLINE  void      mEOL    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDOUBLE_QUOTE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSINGLE_QUOTE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mORDINARY_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mNON_BLANK_CHAR_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mTEXT_LEAD_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mANY_PRINT_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mTAG    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSEMI_COLON_TEXT_FIELD    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDATA_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSAVE_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mLOOP_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mGLOBAL_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSTOP_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDATA_BLOCK_HEADING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSAVE_FRAME_HEADING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSAVE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSINGLE_QUOTED_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDOUBLE_QUOTED_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDIGIT    (pcifLexer ctx);
static ANTLR3_INLINE  void      mEXPONENT    (pcifLexer ctx);
static ANTLR3_INLINE  void      mUNQUOTED_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mCHAR_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mCOMMENTS    (pcifLexer ctx);
static ANTLR3_INLINE  void      mNON_BLANK_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mWHITESPACE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mTokens    (pcifLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN     synpred1_cif    (pcifLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN     synpred2_cif    (pcifLexer ctx);
static void     cifLexerFree(pcifLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
cifLexerFree  (pcifLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
        return fileName;
}

/** \brief Create a new lexer called cifLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pcifLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pcifLexer cifLexerNew
(pANTLR3_INPUT_STREAM instream)
{
        // See if we can create a new lexer with the standard constructor
        //
        return cifLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called cifLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pcifLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pcifLexer cifLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcifLexer ctx; // Context structure we will build and return

    ctx = (pcifLexer) ANTLR3_CALLOC(1, sizeof(cifLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in cifLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer = antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if  (ctx->pLexer == NULL)
    {
                ANTLR3_FREE(ctx);
                return  NULL;
    }
    /* Install the implementation of our cifLexer interface
     */
    ctx->mT__30 = mT__30;
    ctx->mT__31 = mT__31;
    ctx->mT__32 = mT__32;
    ctx->mT__33 = mT__33;
    ctx->mT__34 = mT__34;
    ctx->mT__35 = mT__35;
    ctx->mEOL   = mEOL;
    ctx->mDOUBLE_QUOTE  = mDOUBLE_QUOTE;
    ctx->mSINGLE_QUOTE  = mSINGLE_QUOTE;
    ctx->mORDINARY_CHAR = mORDINARY_CHAR;
    ctx->mNON_BLANK_CHAR_       = mNON_BLANK_CHAR_;
    ctx->mTEXT_LEAD_CHAR        = mTEXT_LEAD_CHAR;
    ctx->mANY_PRINT_CHAR        = mANY_PRINT_CHAR;
    ctx->mTAG   = mTAG;
    ctx->mSEMI_COLON_TEXT_FIELD = mSEMI_COLON_TEXT_FIELD;
    ctx->mDATA_ = mDATA_;
    ctx->mSAVE_ = mSAVE_;
    ctx->mLOOP_ = mLOOP_;
    ctx->mGLOBAL_       = mGLOBAL_;
    ctx->mSTOP_ = mSTOP_;
    ctx->mDATA_BLOCK_HEADING    = mDATA_BLOCK_HEADING;
    ctx->mSAVE_FRAME_HEADING    = mSAVE_FRAME_HEADING;
    ctx->mSAVE  = mSAVE;
    ctx->mSINGLE_QUOTED_STRING  = mSINGLE_QUOTED_STRING;
    ctx->mDOUBLE_QUOTED_STRING  = mDOUBLE_QUOTED_STRING;
    ctx->mDIGIT = mDIGIT;
    ctx->mEXPONENT      = mEXPONENT;
    ctx->mUNQUOTED_STRING       = mUNQUOTED_STRING;
    ctx->mCHAR_STRING   = mCHAR_STRING;
    ctx->mCOMMENTS      = mCOMMENTS;
    ctx->mNON_BLANK_CHAR        = mNON_BLANK_CHAR;
    ctx->mWHITESPACE    = mWHITESPACE;
    ctx->mTokens        = mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx        = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName     = getGrammarFileName;
    ctx->free           = cifLexerFree;




           LEXER->super = (void *)ctx;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | TAG | SEMI_COLON_TEXT_FIELD | LOOP_ | GLOBAL_ | STOP_ | DATA_BLOCK_HEADING | SAVE_FRAME_HEADING | SAVE | DIGIT | EXPONENT | CHAR_STRING | COMMENTS | NON_BLANK_CHAR | WHITESPACE );
 */
static const ANTLR3_INT32 dfa24_eot[210] =
    {
        -1, 45, 47, 48, 49, 50, 51, 43, 46, 46, 46, 46, 46, 99, 46, 43, 43, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, 46, 46, 46, 46, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46, 114, 46, -1, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 131,
        46, 46, 134, 135, 46, -1, 46, 46, -1, -1, 207, 207, 207, 207, 207, 207,
        207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207,
        207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 207, 208,
        208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208,
        208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208,
        208, 208, 208, 208, 209, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_eof[210] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_min[210] =
    {
        9, 33, 33, 33, 33, 33, 33, 65, 9, 79, 76, 65, 65, 33, 43, 9, 9, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 79, 76, 65, 65, 43, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, -1, 79, 79, 79, 79, 79, 86, 79, 86, 84, 84, -1,
        48, 33, 48, -1, 80, 80, 66, 66, 80, 80, 69, 69, 65, 65, -1, 95, 95, 65,
        65, 95, 95, 95, 95, 95, 95, 33, 76, 76, 33, 33, 33, -1, 95, 95, -1, -1,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, -1,
        -1, -1
    };
static const ANTLR3_INT32 dfa24_max[210] =
    {
        126, 126, 126, 126, 126, 126, 126, 122, 126, 111, 108, 116, 97, 126, 57,
        126, 126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 111, 108, 116, 97,
        57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, -1, 111, 111, 111, 111, 111, 118,
        111, 118, 116, 116, -1, 57, 126, 57, -1, 112, 112, 98, 98, 112, 112, 101,
        101, 97, 97, -1, 95, 95, 97, 97, 95, 95, 95, 95, 95, 95, 126, 108, 108,
        126, 126, 126, -1, 95, 95, -1, -1, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_accept[210] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17,
        17, 17, 17, 17, 17, 17, 17, 17, 17, 17, -1, -1, -1, -1, -1, 17, 17, 17,
        17, 17, 17, 17, 17, 17, 18, 19, 20, 1, 17, 2, 3, 4, 5, 6, 7, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 9, -1, -1, 11, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 13, 12, 10
    };
static const ANTLR3_INT32 dfa24_special[210] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa24_T_empty       NULL

static const ANTLR3_INT32 dfa24_T0[] =
    {
        46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa24_T1[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46
    };static const ANTLR3_INT32 dfa24_T2[] =
    {
        136, 163, 165, 166, 137, 138, 164, 139, 140, 141, 142, 143, 144, 145,
        146, 147, 147, 147, 147, 147, 147, 147, 147, 147, 147, 148, 170, 149, 150,
        151, 152, 153, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,
        154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 168,
        156, 169, 157, 167, 158, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155,
        155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155,
        155, 159, 160, 161, 162
    };static const ANTLR3_INT32 dfa24_T3[] =
    {
        44, 44, -1, 44, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 44, 17, 16, 42, 43, 18, 19, 15, 5, 6, 20, 4, 21, 3,
        1, 22, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 23, 8, 24, 25, 26, 2, 27,
        33, 33, 33, 12, 14, 33, 10, 33, 33, 33, 33, 9, 33, 33, 33, 33, 33, 33,
        11, 33, 33, 33, 33, 33, 33, 33, 43, 35, 43, 36, 7, 37, 34, 34, 34, 31,
        32, 34, 29, 34, 34, 34, 34, 28, 34, 34, 34, 34, 34, 34, 30, 34, 34, 34,
        34, 34, 34, 34, 38, 39, 40, 41
    };static const ANTLR3_INT32 dfa24_T4[] =
    {
        123, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 124
    };static const ANTLR3_INT32 dfa24_T5[] =
    {
        130
    };static const ANTLR3_INT32 dfa24_T6[] =
    {
        112, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 113
    };static const ANTLR3_INT32 dfa24_T7[] =
    {
        88, 88, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 88, 53, 80, 82, 83, 54, 55, 81, 56, 57, 58, 59, 60,
        61, 62, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 87, 66, 67, 68,
        69, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
        71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 85, 73, 86, 74, 84, 75, 72, 72,
        72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72,
        72, 72, 72, 72, 72, 72, 76, 77, 78, 79
    };static const ANTLR3_INT32 dfa24_T8[] =
    {
        97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98
    };static const ANTLR3_INT32 dfa24_T9[] =
    {
        89, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90
    };static const ANTLR3_INT32 dfa24_T10[] =
    {
        91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92
    };static const ANTLR3_INT32 dfa24_T11[] =
    {
        171, 198, 200, 201, 172, 173, 199, 174, 175, 176, 177, 178, 179, 180,
        181, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 183, 205, 184, 185,
        186, 187, 188, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
        189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 203,
        191, 204, 192, 202, 193, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190,
        190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190,
        190, 194, 195, 196, 197
    };static const ANTLR3_INT32 dfa24_T12[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 101, 101,
        101, 101, 101, 101, 101, 101, 101, 101, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa24_T13[] =
    {
        206
    };static const ANTLR3_INT32 dfa24_T14[] =
    {
        132, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 133
    };static const ANTLR3_INT32 dfa24_T15[] =
    {
        126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 127
    };static const ANTLR3_INT32 dfa24_T16[] =
    {
        117, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 118
    };static const ANTLR3_INT32 dfa24_T17[] =
    {
        108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 109
    };static const ANTLR3_INT32 dfa24_T18[] =
    {
        119, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 120
    };static const ANTLR3_INT32 dfa24_T19[] =
    {
        52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
        52, 52, 52, 52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52,
        52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
        52, 52, 52, 52
    };static const ANTLR3_INT32 dfa24_T20[] =
    {
        115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 116
    };static const ANTLR3_INT32 dfa24_T21[] =
    {
        125
    };static const ANTLR3_INT32 dfa24_T22[] =
    {
        104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 105
    };static const ANTLR3_INT32 dfa24_T23[] =
    {
        106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 107
    };static const ANTLR3_INT32 dfa24_T24[] =
    {
        128
    };static const ANTLR3_INT32 dfa24_T25[] =
    {
        94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 96, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95
    };static const ANTLR3_INT32 dfa24_T26[] =
    {
        100, -1, 102, -1, -1, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101
    };static const ANTLR3_INT32 dfa24_T27[] =
    {
        101, 101, 101, 101, 101, 101, 101, 101, 101, 101
    };static const ANTLR3_INT32 dfa24_T28[] =
    {
        110, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 111
    };static const ANTLR3_INT32 dfa24_T29[] =
    {
        121, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 122
    };static const ANTLR3_INT32 dfa24_T30[] =
    {
        129
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa24_transitions[] =
{
    dfa24_T3, dfa24_T1, dfa24_T1, dfa24_T1, dfa24_T1, dfa24_T1, dfa24_T1,
    dfa24_T19, dfa24_T7, dfa24_T9, dfa24_T10, dfa24_T25, dfa24_T8, dfa24_T1,
    dfa24_T26, dfa24_T0, dfa24_T0, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T9, dfa24_T10, dfa24_T25,
    dfa24_T8, dfa24_T26, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7,
    dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7,
    dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7,
    dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7,
    dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7, dfa24_T7,
    dfa24_T7, dfa24_T_empty, dfa24_T22, dfa24_T22, dfa24_T23, dfa24_T23,
    dfa24_T17, dfa24_T28, dfa24_T17, dfa24_T28, dfa24_T6, dfa24_T6, dfa24_T_empty,
    dfa24_T27, dfa24_T12, dfa24_T27, dfa24_T_empty, dfa24_T20, dfa24_T20,
    dfa24_T16, dfa24_T16, dfa24_T18, dfa24_T18, dfa24_T29, dfa24_T29, dfa24_T4,
    dfa24_T4, dfa24_T_empty, dfa24_T21, dfa24_T21, dfa24_T15, dfa24_T15,
    dfa24_T24, dfa24_T24, dfa24_T30, dfa24_T30, dfa24_T5, dfa24_T5, dfa24_T1,
    dfa24_T14, dfa24_T14, dfa24_T1, dfa24_T2, dfa24_T11, dfa24_T_empty,
    dfa24_T13, dfa24_T13, dfa24_T_empty, dfa24_T_empty, dfa24_T2, dfa24_T2,
    dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2,
    dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2,
    dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2,
    dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2,
    dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T2, dfa24_T11, dfa24_T11,
    dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11,
    dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11,
    dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11,
    dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11,
    dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T11, dfa24_T1, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty
};


/* Declare tracking structure for Cyclic DFA 24
 */
static
ANTLR3_CYCLIC_DFA cdfa24
    =   {
            24,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"1:1: Tokens : ( T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | TAG | SEMI_COLON_TEXT_FIELD | LOOP_ | GLOBAL_ | STOP_ | DATA_BLOCK_HEADING | SAVE_FRAME_HEADING | SAVE | DIGIT | EXPONENT | CHAR_STRING | COMMENTS | NON_BLANK_CHAR | WHITESPACE );",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa24_eot,      /* EOT table                            */
            dfa24_eof,      /* EOF table                            */
            dfa24_min,      /* Minimum tokens for each state    */
            dfa24_max,      /* Maximum tokens for each state    */
            dfa24_accept,       /* Accept table                     */
            dfa24_special,      /* Special transition states        */
            dfa24_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 24
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 28:7: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__30
 *
 * Looks to match the characters the constitute the token T__30
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__30(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__30;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:28:7: ( '.' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:28:9: '.'
    {
        MATCHC('.');
        if  (HASEXCEPTION())
        {
            goto ruleT__30Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__30Ex; /* Prevent compiler warnings */
    ruleT__30Ex: ;

}
// $ANTLR end T__30

//   Comes from: 29:7: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__31
 *
 * Looks to match the characters the constitute the token T__31
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__31(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__31;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:29:7: ( '?' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:29:9: '?'
    {
        MATCHC('?');
        if  (HASEXCEPTION())
        {
            goto ruleT__31Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__31Ex; /* Prevent compiler warnings */
    ruleT__31Ex: ;

}
// $ANTLR end T__31

//   Comes from: 30:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__32
 *
 * Looks to match the characters the constitute the token T__32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__32(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__32;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:30:7: ( '-' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:30:9: '-'
    {
        MATCHC('-');
        if  (HASEXCEPTION())
        {
            goto ruleT__32Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__32Ex; /* Prevent compiler warnings */
    ruleT__32Ex: ;

}
// $ANTLR end T__32

//   Comes from: 31:7: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__33
 *
 * Looks to match the characters the constitute the token T__33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__33(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__33;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:31:7: ( '+' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:31:9: '+'
    {
        MATCHC('+');
        if  (HASEXCEPTION())
        {
            goto ruleT__33Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__33Ex; /* Prevent compiler warnings */
    ruleT__33Ex: ;

}
// $ANTLR end T__33

//   Comes from: 32:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__34
 *
 * Looks to match the characters the constitute the token T__34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__34(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__34;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:32:7: ( '(' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:32:9: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION())
        {
            goto ruleT__34Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__34Ex; /* Prevent compiler warnings */
    ruleT__34Ex: ;

}
// $ANTLR end T__34

//   Comes from: 33:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__35
 *
 * Looks to match the characters the constitute the token T__35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__35(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__35;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:33:7: ( ')' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:33:9: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION())
        {
            goto ruleT__35Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__35Ex; /* Prevent compiler warnings */
    ruleT__35Ex: ;

}
// $ANTLR end T__35

//   Comes from: 203:2: ( ( '\\n' | '\\r' | '\\r\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EOL
 *
 * Looks to match the characters the constitute the token EOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEOL(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:203:2: ( ( '\\n' | '\\r' | '\\r\\n' ) )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:203:4: ( '\\n' | '\\r' | '\\r\\n' )
    {

        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:203:4: ( '\\n' | '\\r' | '\\r\\n' )
        {
            int alt1=3;
            switch ( LA(1) )
            {
            case '\n':
                {
                        alt1=1;
                }
                break;
            case '\r':
                {
                        switch ( LA(2) )
                        {
                        case '\n':
                                {
                                        alt1=3;
                                }
                            break;

                        default:
                            alt1=2;}

                }
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleEOLEx;
            }

            switch (alt1)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:203:6: '\\n'
                    {
                        MATCHC('\n');
                        if  (HASEXCEPTION())
                        {
                            goto ruleEOLEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:203:13: '\\r'
                    {
                        MATCHC('\r');
                        if  (HASEXCEPTION())
                        {
                            goto ruleEOLEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:203:20: '\\r\\n'
                    {
                        MATCHS(lit_1);
                        if  (HASEXCEPTION())
                        {
                            goto ruleEOLEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }


                    }
                    break;

            }
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEOLEx; /* Prevent compiler warnings */
    ruleEOLEx: ;

}
// $ANTLR end EOL

//   Comes from: 206:2: ( '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTE
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:206:2: ( '\"' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:206:4: '\"'
    {
        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTEEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTEEx: ;

}
// $ANTLR end DOUBLE_QUOTE

//   Comes from: 209:2: ( '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINGLE_QUOTE
 *
 * Looks to match the characters the constitute the token SINGLE_QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINGLE_QUOTE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:209:2: ( '\\'' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:209:4: '\\''
    {
        MATCHC('\'');
        if  (HASEXCEPTION())
        {
            goto ruleSINGLE_QUOTEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSINGLE_QUOTEEx; /* Prevent compiler warnings */
    ruleSINGLE_QUOTEEx: ;

}
// $ANTLR end SINGLE_QUOTE

//   Comes from: 212:2: ( '!' | '%' | '&' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | ( '0' .. '9' ) | ':' | '<' | '=' | '>' | '?' | '@' | ( 'A' .. 'Z' ) | ( 'a' .. 'z' ) | '\\\\' | '^' | '`' | '{' | '|' | '}' | '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ORDINARY_CHAR
 *
 * Looks to match the characters the constitute the token ORDINARY_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mORDINARY_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:2: ( '!' | '%' | '&' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | ( '0' .. '9' ) | ':' | '<' | '=' | '>' | '?' | '@' | ( 'A' .. 'Z' ) | ( 'a' .. 'z' ) | '\\\\' | '^' | '`' | '{' | '|' | '}' | '~' )

        ANTLR3_UINT32 alt2;

        alt2=27;

        switch ( LA(1) )
        {
        case '!':
                {
                        alt2=1;
                }
            break;
        case '%':
                {
                        alt2=2;
                }
            break;
        case '&':
                {
                        alt2=3;
                }
            break;
        case '(':
                {
                        alt2=4;
                }
            break;
        case ')':
                {
                        alt2=5;
                }
            break;
        case '*':
                {
                        alt2=6;
                }
            break;
        case '+':
                {
                        alt2=7;
                }
            break;
        case ',':
                {
                        alt2=8;
                }
            break;
        case '-':
                {
                        alt2=9;
                }
            break;
        case '.':
                {
                        alt2=10;
                }
            break;
        case '/':
                {
                        alt2=11;
                }
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
                {
                        alt2=12;
                }
            break;
        case ':':
                {
                        alt2=13;
                }
            break;
        case '<':
                {
                        alt2=14;
                }
            break;
        case '=':
                {
                        alt2=15;
                }
            break;
        case '>':
                {
                        alt2=16;
                }
            break;
        case '?':
                {
                        alt2=17;
                }
            break;
        case '@':
                {
                        alt2=18;
                }
            break;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
                {
                        alt2=19;
                }
            break;
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
                {
                        alt2=20;
                }
            break;
        case '\\':
                {
                        alt2=21;
                }
            break;
        case '^':
                {
                        alt2=22;
                }
            break;
        case '`':
                {
                        alt2=23;
                }
            break;
        case '{':
                {
                        alt2=24;
                }
            break;
        case '|':
                {
                        alt2=25;
                }
            break;
        case '}':
                {
                        alt2=26;
                }
            break;
        case '~':
                {
                        alt2=27;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 2;
            EXCEPTION->state        = 0;


            goto ruleORDINARY_CHAREx;
        }

        switch (alt2)
        {
        case 1:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:5: '!'
            {
                MATCHC('!');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:11: '%'
            {
                MATCHC('%');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:17: '&'
            {
                MATCHC('&');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:23: '('
            {
                MATCHC('(');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:29: ')'
            {
                MATCHC(')');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:35: '*'
            {
                MATCHC('*');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:41: '+'
            {
                MATCHC('+');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:47: ','
            {
                MATCHC(',');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:53: '-'
            {
                MATCHC('-');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 10:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:59: '.'
            {
                MATCHC('.');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 11:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:212:65: '/'
            {
                MATCHC('/');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 12:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:2: ( '0' .. '9' )
            {
                // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:2: ( '0' .. '9' )
                // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:4: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION())
                    {
                        goto ruleORDINARY_CHAREx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }

                }


            }
            break;
        case 13:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:18: ':'
            {
                MATCHC(':');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 14:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:24: '<'
            {
                MATCHC('<');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 15:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:30: '='
            {
                MATCHC('=');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 16:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:36: '>'
            {
                MATCHC('>');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 17:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:42: '?'
            {
                MATCHC('?');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 18:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:48: '@'
            {
                MATCHC('@');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 19:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:54: ( 'A' .. 'Z' )
            {
                // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:54: ( 'A' .. 'Z' )
                // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:55: 'A' .. 'Z'
                {
                    MATCHRANGE('A', 'Z');
                    if  (HASEXCEPTION())
                    {
                        goto ruleORDINARY_CHAREx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }

                }


            }
            break;
        case 20:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:67: ( 'a' .. 'z' )
            {
                // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:67: ( 'a' .. 'z' )
                // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:213:68: 'a' .. 'z'
                {
                    MATCHRANGE('a', 'z');
                    if  (HASEXCEPTION())
                    {
                        goto ruleORDINARY_CHAREx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }

                }


            }
            break;
        case 21:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:2: '\\\\'
            {
                MATCHC('\\');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 22:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:9: '^'
            {
                MATCHC('^');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 23:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:15: '`'
            {
                MATCHC('`');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 24:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:21: '{'
            {
                MATCHC('{');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 25:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:27: '|'
            {
                MATCHC('|');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 26:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:33: '}'
            {
                MATCHC('}');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 27:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:214:39: '~'
            {
                MATCHC('~');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleORDINARY_CHAREx; /* Prevent compiler warnings */
    ruleORDINARY_CHAREx: ;

}
// $ANTLR end ORDINARY_CHAR

//   Comes from: 219:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NON_BLANK_CHAR_
 *
 * Looks to match the characters the constitute the token NON_BLANK_CHAR_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNON_BLANK_CHAR_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ';' )

        ANTLR3_UINT32 alt3;

        alt3=9;

        switch ( LA(1) )
        {
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt3=1;
                }
            break;
        case '"':
                {
                        alt3=2;
                }
            break;
        case '\'':
                {
                        alt3=3;
                }
            break;
        case '#':
                {
                        alt3=4;
                }
            break;
        case '$':
                {
                        alt3=5;
                }
            break;
        case '_':
                {
                        alt3=6;
                }
            break;
        case '[':
                {
                        alt3=7;
                }
            break;
        case ']':
                {
                        alt3=8;
                }
            break;
        case ';':
                {
                        alt3=9;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 3;
            EXCEPTION->state        = 0;


            goto ruleNON_BLANK_CHAR_Ex;
        }

        switch (alt3)
        {
        case 1:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:4: ORDINARY_CHAR
            {
                /* 219:4: ORDINARY_CHAR */
                mORDINARY_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:20: DOUBLE_QUOTE
            {
                /* 219:20: DOUBLE_QUOTE */
                mDOUBLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:35: SINGLE_QUOTE
            {
                /* 219:35: SINGLE_QUOTE */
                mSINGLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:50: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:56: '$'
            {
                MATCHC('$');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:62: '_'
            {
                MATCHC('_');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:68: '['
            {
                MATCHC('[');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:74: ']'
            {
                MATCHC(']');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:219:80: ';'
            {
                MATCHC(';');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleNON_BLANK_CHAR_Ex; /* Prevent compiler warnings */
    ruleNON_BLANK_CHAR_Ex: ;

}
// $ANTLR end NON_BLANK_CHAR_

//   Comes from: 222:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TEXT_LEAD_CHAR
 *
 * Looks to match the characters the constitute the token TEXT_LEAD_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTEXT_LEAD_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' )

        ANTLR3_UINT32 alt4;

        alt4=10;

        switch ( LA(1) )
        {
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt4=1;
                }
            break;
        case '"':
                {
                        alt4=2;
                }
            break;
        case '\'':
                {
                        alt4=3;
                }
            break;
        case '#':
                {
                        alt4=4;
                }
            break;
        case '$':
                {
                        alt4=5;
                }
            break;
        case '_':
                {
                        alt4=6;
                }
            break;
        case '[':
                {
                        alt4=7;
                }
            break;
        case ']':
                {
                        alt4=8;
                }
            break;
        case ' ':
                {
                        alt4=9;
                }
            break;
        case '\t':
                {
                        alt4=10;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleTEXT_LEAD_CHAREx;
        }

        switch (alt4)
        {
        case 1:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:4: ORDINARY_CHAR
            {
                /* 222:4: ORDINARY_CHAR */
                mORDINARY_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:20: DOUBLE_QUOTE
            {
                /* 222:20: DOUBLE_QUOTE */
                mDOUBLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:35: SINGLE_QUOTE
            {
                /* 222:35: SINGLE_QUOTE */
                mSINGLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:50: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:56: '$'
            {
                MATCHC('$');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:62: '_'
            {
                MATCHC('_');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:68: '['
            {
                MATCHC('[');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:74: ']'
            {
                MATCHC(']');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:80: ' '
            {
                MATCHC(' ');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 10:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:222:86: '\\t'
            {
                MATCHC('\t');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleTEXT_LEAD_CHAREx; /* Prevent compiler warnings */
    ruleTEXT_LEAD_CHAREx: ;

}
// $ANTLR end TEXT_LEAD_CHAR

//   Comes from: 225:2: ( ORDINARY_CHAR | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' | ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANY_PRINT_CHAR
 *
 * Looks to match the characters the constitute the token ANY_PRINT_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANY_PRINT_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:2: ( ORDINARY_CHAR | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' | ';' )

        ANTLR3_UINT32 alt5;

        alt5=9;

        switch ( LA(1) )
        {
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt5=1;
                }
            break;
        case '#':
                {
                        alt5=2;
                }
            break;
        case '$':
                {
                        alt5=3;
                }
            break;
        case '_':
                {
                        alt5=4;
                }
            break;
        case '[':
                {
                        alt5=5;
                }
            break;
        case ']':
                {
                        alt5=6;
                }
            break;
        case ' ':
                {
                        alt5=7;
                }
            break;
        case '\t':
                {
                        alt5=8;
                }
            break;
        case ';':
                {
                        alt5=9;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 5;
            EXCEPTION->state        = 0;


            goto ruleANY_PRINT_CHAREx;
        }

        switch (alt5)
        {
        case 1:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:4: ORDINARY_CHAR
            {
                /* 225:4: ORDINARY_CHAR */
                mORDINARY_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:20: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:26: '$'
            {
                MATCHC('$');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:32: '_'
            {
                MATCHC('_');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:38: '['
            {
                MATCHC('[');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:44: ']'
            {
                MATCHC(']');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:50: ' '
            {
                MATCHC(' ');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:56: '\\t'
            {
                MATCHC('\t');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:225:63: ';'
            {
                MATCHC(';');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleANY_PRINT_CHAREx; /* Prevent compiler warnings */
    ruleANY_PRINT_CHAREx: ;

}
// $ANTLR end ANY_PRINT_CHAR

//   Comes from: 231:5: ( '_' ( 'A' .. 'Z' | 'a' .. 'z' ) ( NON_BLANK_CHAR_ )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TAG
 *
 * Looks to match the characters the constitute the token TAG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTAG(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = TAG;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:231:5: ( '_' ( 'A' .. 'Z' | 'a' .. 'z' ) ( NON_BLANK_CHAR_ )* )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:231:7: '_' ( 'A' .. 'Z' | 'a' .. 'z' ) ( NON_BLANK_CHAR_ )*
    {
        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleTAGEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleTAGEx;
        }


        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:231:35: ( NON_BLANK_CHAR_ )*

        for (;;)
        {
            int alt6=2;
            switch ( LA(1) )
            {
            case '!':
            case '"':
            case '#':
            case '$':
            case '%':
            case '&':
            case '\'':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt6=1;
                }
                break;

            }

            switch (alt6)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:231:36: NON_BLANK_CHAR_
                    {
                        /* 231:36: NON_BLANK_CHAR_ */
                        mNON_BLANK_CHAR_(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleTAGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop6; /* break out of the loop */
                    break;
            }
        }
        loop6: ; /* Jump out to here if this rule does not match */


    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTAGEx; /* Prevent compiler warnings */
    ruleTAGEx: ;

}
// $ANTLR end TAG

//   Comes from: 238:2: ( ';' ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* ) ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMI_COLON_TEXT_FIELD
 *
 * Looks to match the characters the constitute the token SEMI_COLON_TEXT_FIELD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEMI_COLON_TEXT_FIELD(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = SEMI_COLON_TEXT_FIELD;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:238:2: ( ';' ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* ) ';' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:238:4: ';' ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* ) ';'
    {
        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleSEMI_COLON_TEXT_FIELDEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:239:3: ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:239:5: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )*
        {

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:239:5: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*

            for (;;)
            {
                int alt7=4;
                switch ( LA(1) )
                {
                case '\t':
                case ' ':
                case '!':
                case '#':
                case '$':
                case '%':
                case '&':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt7=1;
                        }
                    break;
                case '\'':
                        {
                                alt7=2;
                        }
                    break;
                case '"':
                        {
                                alt7=3;
                        }
                    break;

                }

                switch (alt7)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:239:7: ANY_PRINT_CHAR
                    {
                        /* 239:7: ANY_PRINT_CHAR */
                        mANY_PRINT_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:239:24: SINGLE_QUOTE
                    {
                        /* 239:24: SINGLE_QUOTE */
                        mSINGLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:239:39: DOUBLE_QUOTE
                    {
                        /* 239:39: DOUBLE_QUOTE */
                        mDOUBLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop7; /* break out of the loop */
                    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */

            /* 239:5: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* */
            mEOL(ctx );
            if  (HASEXCEPTION())
            {
                goto ruleSEMI_COLON_TEXT_FIELDEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:3: ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case '\t':
                case '\n':
                case '\r':
                case ' ':
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt10=1;
                        }
                    break;

                }

                switch (alt10)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:5: ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL
                    {

                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:5: ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )?
                        {
                            int alt9=2;
                            switch ( LA(1) )
                            {
                                case '\t':
                                case ' ':
                                case '!':
                                case '"':
                                case '#':
                                case '$':
                                case '%':
                                case '&':
                                case '\'':
                                case '(':
                                case ')':
                                case '*':
                                case '+':
                                case ',':
                                case '-':
                                case '.':
                                case '/':
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case ':':
                                case '<':
                                case '=':
                                case '>':
                                case '?':
                                case '@':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'G':
                                case 'H':
                                case 'I':
                                case 'J':
                                case 'K':
                                case 'L':
                                case 'M':
                                case 'N':
                                case 'O':
                                case 'P':
                                case 'Q':
                                case 'R':
                                case 'S':
                                case 'T':
                                case 'U':
                                case 'V':
                                case 'W':
                                case 'X':
                                case 'Y':
                                case 'Z':
                                case '[':
                                case '\\':
                                case ']':
                                case '^':
                                case '_':
                                case '`':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'g':
                                case 'h':
                                case 'i':
                                case 'j':
                                case 'k':
                                case 'l':
                                case 'm':
                                case 'n':
                                case 'o':
                                case 'p':
                                case 'q':
                                case 'r':
                                case 's':
                                case 't':
                                case 'u':
                                case 'v':
                                case 'w':
                                case 'x':
                                case 'y':
                                case 'z':
                                case '{':
                                case '|':
                                case '}':
                                case '~':
                                        {
                                                alt9=1;
                                        }
                                    break;
                            }

                            switch (alt9)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:6: TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*
                                    {
                                        /* 240:6: TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* */
                                        mTEXT_LEAD_CHAR(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:21: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*

                                        for (;;)
                                        {
                                            int alt8=4;
                                            switch ( LA(1) )
                                            {
                                            case '\t':
                                            case ' ':
                                            case '!':
                                            case '#':
                                            case '$':
                                            case '%':
                                            case '&':
                                            case '(':
                                            case ')':
                                            case '*':
                                            case '+':
                                            case ',':
                                            case '-':
                                            case '.':
                                            case '/':
                                            case '0':
                                            case '1':
                                            case '2':
                                            case '3':
                                            case '4':
                                            case '5':
                                            case '6':
                                            case '7':
                                            case '8':
                                            case '9':
                                            case ':':
                                            case ';':
                                            case '<':
                                            case '=':
                                            case '>':
                                            case '?':
                                            case '@':
                                            case 'A':
                                            case 'B':
                                            case 'C':
                                            case 'D':
                                            case 'E':
                                            case 'F':
                                            case 'G':
                                            case 'H':
                                            case 'I':
                                            case 'J':
                                            case 'K':
                                            case 'L':
                                            case 'M':
                                            case 'N':
                                            case 'O':
                                            case 'P':
                                            case 'Q':
                                            case 'R':
                                            case 'S':
                                            case 'T':
                                            case 'U':
                                            case 'V':
                                            case 'W':
                                            case 'X':
                                            case 'Y':
                                            case 'Z':
                                            case '[':
                                            case '\\':
                                            case ']':
                                            case '^':
                                            case '_':
                                            case '`':
                                            case 'a':
                                            case 'b':
                                            case 'c':
                                            case 'd':
                                            case 'e':
                                            case 'f':
                                            case 'g':
                                            case 'h':
                                            case 'i':
                                            case 'j':
                                            case 'k':
                                            case 'l':
                                            case 'm':
                                            case 'n':
                                            case 'o':
                                            case 'p':
                                            case 'q':
                                            case 'r':
                                            case 's':
                                            case 't':
                                            case 'u':
                                            case 'v':
                                            case 'w':
                                            case 'x':
                                            case 'y':
                                            case 'z':
                                            case '{':
                                            case '|':
                                            case '}':
                                            case '~':
                                                {
                                                        alt8=1;
                                                }
                                                break;
                                            case '\'':
                                                {
                                                        alt8=2;
                                                }
                                                break;
                                            case '"':
                                                {
                                                        alt8=3;
                                                }
                                                break;

                                            }

                                            switch (alt8)
                                            {
                                                case 1:
                                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:23: ANY_PRINT_CHAR
                                                    {
                                                        /* 240:23: ANY_PRINT_CHAR */
                                                        mANY_PRINT_CHAR(ctx );
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                                        }
                                                        if (HASFAILED())
                                                        {
                                                            return ;
                                                        }

                                                    }
                                                    break;
                                                case 2:
                                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:40: SINGLE_QUOTE
                                                    {
                                                        /* 240:40: SINGLE_QUOTE */
                                                        mSINGLE_QUOTE(ctx );
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                                        }
                                                        if (HASFAILED())
                                                        {
                                                            return ;
                                                        }

                                                    }
                                                    break;
                                                case 3:
                                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:240:55: DOUBLE_QUOTE
                                                    {
                                                        /* 240:55: DOUBLE_QUOTE */
                                                        mDOUBLE_QUOTE(ctx );
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                                        }
                                                        if (HASFAILED())
                                                        {
                                                            return ;
                                                        }

                                                    }
                                                    break;

                                                default:
                                                    goto loop8; /* break out of the loop */
                                                    break;
                                            }
                                        }
                                        loop8: ; /* Jump out to here if this rule does not match */


                                    }
                                    break;

                            }
                        }
                        /* 240:5: ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL */
                        mEOL(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop10;        /* break out of the loop */
                    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleSEMI_COLON_TEXT_FIELDEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSEMI_COLON_TEXT_FIELDEx; /* Prevent compiler warnings */
    ruleSEMI_COLON_TEXT_FIELDEx: ;

}
// $ANTLR end SEMI_COLON_TEXT_FIELD

//   Comes from: 249:7: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATA_
 *
 * Looks to match the characters the constitute the token DATA_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDATA_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:249:7: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) '_' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:249:9: ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) '_'
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleDATA_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDATA_Ex; /* Prevent compiler warnings */
    ruleDATA_Ex: ;

}
// $ANTLR end DATA_

//   Comes from: 252:7: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'E' | 'e' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE_
 *
 * Looks to match the characters the constitute the token SAVE_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:252:7: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'E' | 'e' ) '_' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:252:9: ( 'S' | 's' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'E' | 'e' ) '_'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleSAVE_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSAVE_Ex; /* Prevent compiler warnings */
    ruleSAVE_Ex: ;

}
// $ANTLR end SAVE_

//   Comes from: 254:8: ( ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOOP_
 *
 * Looks to match the characters the constitute the token LOOP_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOOP_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = LOOP_;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:254:8: ( ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:254:10: ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_'
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleLOOP_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLOOP_Ex; /* Prevent compiler warnings */
    ruleLOOP_Ex: ;

}
// $ANTLR end LOOP_

//   Comes from: 256:9: ( ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'L' | 'l' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GLOBAL_
 *
 * Looks to match the characters the constitute the token GLOBAL_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGLOBAL_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = GLOBAL_;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:256:9: ( ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'L' | 'l' ) '_' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:256:11: ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'L' | 'l' ) '_'
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleGLOBAL_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGLOBAL_Ex; /* Prevent compiler warnings */
    ruleGLOBAL_Ex: ;

}
// $ANTLR end GLOBAL_

//   Comes from: 258:7: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STOP_
 *
 * Looks to match the characters the constitute the token STOP_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTOP_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = STOP_;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:258:7: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:258:9: ( 'S' | 's' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleSTOP_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTOP_Ex; /* Prevent compiler warnings */
    ruleSTOP_Ex: ;

}
// $ANTLR end STOP_

//   Comes from: 267:2: ( DATA_ ( NON_BLANK_CHAR )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATA_BLOCK_HEADING
 *
 * Looks to match the characters the constitute the token DATA_BLOCK_HEADING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDATA_BLOCK_HEADING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = DATA_BLOCK_HEADING;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:267:2: ( DATA_ ( NON_BLANK_CHAR )+ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:267:4: DATA_ ( NON_BLANK_CHAR )+
    {
        /* 267:4: DATA_ ( NON_BLANK_CHAR )+ */
        mDATA_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDATA_BLOCK_HEADINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:267:10: ( NON_BLANK_CHAR )+
        {
            int cnt11=0;

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt11=1;
                        }
                    break;

                }

                switch (alt11)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:267:11: NON_BLANK_CHAR
                        {
                            /* 267:11: NON_BLANK_CHAR */
                            mNON_BLANK_CHAR(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleDATA_BLOCK_HEADINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt11 >= 1 )
                        {
                            goto loop11;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleDATA_BLOCK_HEADINGEx;
                }
                cnt11++;
            }
            loop11: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDATA_BLOCK_HEADINGEx; /* Prevent compiler warnings */
    ruleDATA_BLOCK_HEADINGEx: ;

}
// $ANTLR end DATA_BLOCK_HEADING

//   Comes from: 270:2: ( SAVE_ ( NON_BLANK_CHAR )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE_FRAME_HEADING
 *
 * Looks to match the characters the constitute the token SAVE_FRAME_HEADING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE_FRAME_HEADING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = SAVE_FRAME_HEADING;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:270:2: ( SAVE_ ( NON_BLANK_CHAR )+ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:270:4: SAVE_ ( NON_BLANK_CHAR )+
    {
        /* 270:4: SAVE_ ( NON_BLANK_CHAR )+ */
        mSAVE_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSAVE_FRAME_HEADINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:270:10: ( NON_BLANK_CHAR )+
        {
            int cnt12=0;

            for (;;)
            {
                int alt12=2;
                switch ( LA(1) )
                {
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt12=1;
                        }
                    break;

                }

                switch (alt12)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:270:11: NON_BLANK_CHAR
                        {
                            /* 270:11: NON_BLANK_CHAR */
                            mNON_BLANK_CHAR(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleSAVE_FRAME_HEADINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt12 >= 1 )
                        {
                            goto loop12;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleSAVE_FRAME_HEADINGEx;
                }
                cnt12++;
            }
            loop12: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSAVE_FRAME_HEADINGEx; /* Prevent compiler warnings */
    ruleSAVE_FRAME_HEADINGEx: ;

}
// $ANTLR end SAVE_FRAME_HEADING

//   Comes from: 272:6: ( SAVE_ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE
 *
 * Looks to match the characters the constitute the token SAVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = SAVE;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:272:6: ( SAVE_ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:272:8: SAVE_
    {
        /* 272:8: SAVE_ */
        mSAVE_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSAVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSAVEEx; /* Prevent compiler warnings */
    ruleSAVEEx: ;

}
// $ANTLR end SAVE

//   Comes from: 276:2: ( SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINGLE_QUOTED_STRING
 *
 * Looks to match the characters the constitute the token SINGLE_QUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINGLE_QUOTED_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:276:2: ( SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:276:4: SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE
    {
        /* 276:4: SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE */
        mSINGLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSINGLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:3: ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )*

        for (;;)
        {
            int alt13=4;
            switch ( LA(1) )
            {
            case '\'':
                {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA13_1 = LA(2);
                            if ( (LA13_1 == '\'') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '!') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '%') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '&') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '(') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ')') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '*') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '+') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ',') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '-') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '.') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '/') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (((LA13_1 >= '0') && (LA13_1 <= '9'))) && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ':') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '<') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '=') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '>') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '?') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '@') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (((LA13_1 >= 'A') && (LA13_1 <= 'Z'))) && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (((LA13_1 >= 'a') && (LA13_1 <= 'z'))) && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '\\') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '^') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '`') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '{') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '|') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '}') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '~') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '#') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '$') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '_') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '[') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ']') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ' ') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '\t') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ';') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '"') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }

                        }
                }
                break;
            case '\t':
            case ' ':
            case '!':
            case '#':
            case '$':
            case '%':
            case '&':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt13=2;
                }
                break;
            case '"':
                {
                        alt13=3;
                }
                break;

            }

            switch (alt13)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:5: ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE )
                    {
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:5: ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE )
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:7: ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE
                        {
                            /* 277:7: ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE */
                            mSINGLE_QUOTE(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleSINGLE_QUOTED_STRINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:56: ANY_PRINT_CHAR
                    {
                        /* 277:56: ANY_PRINT_CHAR */
                        mANY_PRINT_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSINGLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:73: DOUBLE_QUOTE
                    {
                        /* 277:73: DOUBLE_QUOTE */
                        mDOUBLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSINGLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop13;        /* break out of the loop */
                    break;
            }
        }
        loop13: ; /* Jump out to here if this rule does not match */

        /* 276:4: SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE */
        mSINGLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSINGLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSINGLE_QUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleSINGLE_QUOTED_STRINGEx: ;

}
// $ANTLR end SINGLE_QUOTED_STRING

//   Comes from: 282:2: ( DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTED_STRING
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTED_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:282:2: ( DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:282:4: DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE
    {
        /* 282:4: DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE */
        mDOUBLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:3: ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )*

        for (;;)
        {
            int alt14=4;
            switch ( LA(1) )
            {
            case '"':
                {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA14_1 = LA(2);
                            if ( (LA14_1 == '"') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '!') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '%') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '&') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '(') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ')') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '*') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '+') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ',') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '-') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '.') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '/') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (((LA14_1 >= '0') && (LA14_1 <= '9'))) && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ':') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '<') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '=') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '>') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '?') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '@') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (((LA14_1 >= 'A') && (LA14_1 <= 'Z'))) && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (((LA14_1 >= 'a') && (LA14_1 <= 'z'))) && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '\\') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '^') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '`') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '{') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '|') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '}') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '~') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '#') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '$') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '_') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '[') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ']') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ' ') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '\t') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ';') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '\'') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }

                        }
                }
                break;
            case '\t':
            case ' ':
            case '!':
            case '#':
            case '$':
            case '%':
            case '&':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt14=2;
                }
                break;
            case '\'':
                {
                        alt14=3;
                }
                break;

            }

            switch (alt14)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:5: ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE )
                    {
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:5: ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE )
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:7: ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE
                        {
                            /* 283:7: ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE */
                            mDOUBLE_QUOTE(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleDOUBLE_QUOTED_STRINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:56: ANY_PRINT_CHAR
                    {
                        /* 283:56: ANY_PRINT_CHAR */
                        mANY_PRINT_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleDOUBLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:73: SINGLE_QUOTE
                    {
                        /* 283:73: SINGLE_QUOTE */
                        mSINGLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleDOUBLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop14;        /* break out of the loop */
                    break;
            }
        }
        loop14: ; /* Jump out to here if this rule does not match */

        /* 282:4: DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE */
        mDOUBLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTED_STRINGEx: ;

}
// $ANTLR end DOUBLE_QUOTED_STRING

//   Comes from: 291:7: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = DIGIT;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:291:7: ( '0' .. '9' )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:291:9: '0' .. '9'
    {
        MATCHRANGE('0', '9');
        if  (HASEXCEPTION())
        {
            goto ruleDIGITEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 293:9: ( ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) ) ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = EXPONENT;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:9: ( ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) ) ( DIGIT )+ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:12: ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) ) ( DIGIT )+
    {

        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:12: ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) )
        {
            int alt15=2;
            switch ( LA(1) )
            {
            case 'E':
            case 'e':
                {
                        switch ( LA(2) )
                        {
                        case '+':
                        case '-':
                                {
                                        alt15=2;
                                }
                            break;
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                                {
                                        alt15=1;
                                }
                            break;

                        default:
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 15;
                            EXCEPTION->state        = 1;


                            goto ruleEXPONENTEx;
                        }

                }
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruleEXPONENTEx;
            }

            switch (alt15)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:14: ( 'e' | 'E' )
                    {
                        if ( LA(1) == 'E' || LA(1) == 'e' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleEXPONENTEx;
                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:29: ( 'e' | 'E' ) ( '+' | '-' )
                    {
                        if ( LA(1) == 'E' || LA(1) == 'e' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleEXPONENTEx;
                        }

                        if ( LA(1) == '+' || LA(1) == '-' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleEXPONENTEx;
                        }


                    }
                    break;

            }
        }
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:57: ( DIGIT )+
        {
            int cnt16=0;

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                        {
                                alt16=1;
                        }
                    break;

                }

                switch (alt16)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:293:58: DIGIT
                        {
                            /* 293:58: DIGIT */
                            mDIGIT(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleEXPONENTEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt16 >= 1 )
                        {
                            goto loop16;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleEXPONENTEx;
                }
                cnt16++;
            }
            loop16: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 298:2: ( ( ORDINARY_CHAR | ';' ) ( NON_BLANK_CHAR_ )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNQUOTED_STRING
 *
 * Looks to match the characters the constitute the token UNQUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNQUOTED_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:2: ( ( ORDINARY_CHAR | ';' ) ( NON_BLANK_CHAR_ )* )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:4: ( ORDINARY_CHAR | ';' ) ( NON_BLANK_CHAR_ )*
    {

        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:4: ( ORDINARY_CHAR | ';' )
        {
            int alt17=2;
            switch ( LA(1) )
            {
            case '!':
            case '%':
            case '&':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '\\':
            case '^':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt17=1;
                }
                break;
            case ';':
                {
                        alt17=2;
                }
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruleUNQUOTED_STRINGEx;
            }

            switch (alt17)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:6: ORDINARY_CHAR
                    {
                        /* 298:6: ORDINARY_CHAR */
                        mORDINARY_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleUNQUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:22: ';'
                    {
                        MATCHC(';');
                        if  (HASEXCEPTION())
                        {
                            goto ruleUNQUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

            }
        }

        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:28: ( NON_BLANK_CHAR_ )*

        for (;;)
        {
            int alt18=2;
            switch ( LA(1) )
            {
            case '!':
            case '"':
            case '#':
            case '$':
            case '%':
            case '&':
            case '\'':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt18=1;
                }
                break;

            }

            switch (alt18)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:298:29: NON_BLANK_CHAR_
                    {
                        /* 298:29: NON_BLANK_CHAR_ */
                        mNON_BLANK_CHAR_(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleUNQUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop18;        /* break out of the loop */
                    break;
            }
        }
        loop18: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleUNQUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleUNQUOTED_STRINGEx: ;

}
// $ANTLR end UNQUOTED_STRING

//   Comes from: 301:2: ( SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING | UNQUOTED_STRING )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING
 *
 * Looks to match the characters the constitute the token CHAR_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHAR_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = CHAR_STRING;


    {
        //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:301:2: ( SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING | UNQUOTED_STRING )

        ANTLR3_UINT32 alt19;

        alt19=3;

        switch ( LA(1) )
        {
        case '\'':
                {
                        alt19=1;
                }
            break;
        case '"':
                {
                        alt19=2;
                }
            break;
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt19=3;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 19;
            EXCEPTION->state        = 0;


            goto ruleCHAR_STRINGEx;
        }

        switch (alt19)
        {
        case 1:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:301:4: SINGLE_QUOTED_STRING
            {
                /* 301:4: SINGLE_QUOTED_STRING */
                mSINGLE_QUOTED_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleCHAR_STRINGEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:301:27: DOUBLE_QUOTED_STRING
            {
                /* 301:27: DOUBLE_QUOTED_STRING */
                mDOUBLE_QUOTED_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleCHAR_STRINGEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:301:50: UNQUOTED_STRING
            {
                /* 301:50: UNQUOTED_STRING */
                mUNQUOTED_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleCHAR_STRINGEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }
        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRINGEx; /* Prevent compiler warnings */
    ruleCHAR_STRINGEx: ;

}
// $ANTLR end CHAR_STRING

//   Comes from: 308:2: ( ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENTS
 *
 * Looks to match the characters the constitute the token COMMENTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENTS(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = COMMENTS;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:2: ( ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ ) )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:4: ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ )
    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:4: ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:6: ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+
        {
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:6: ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+
            {
                int cnt22=0;

                for (;;)
                {
                    int alt22=2;
                switch ( LA(1) )
                {
                case '#':
                        {
                                alt22=1;
                        }
                    break;

                }

                switch (alt22)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:8: '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?)
                        {
                            MATCHC('#');
                            if  (HASEXCEPTION())
                            {
                                goto ruleCOMMENTSEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:12: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*

                            for (;;)
                            {
                                int alt20=4;
                                switch ( LA(1) )
                                {
                                case '#':
                                        {
                                                {
                                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                                    */
                                                    int LA20_2 = LA(2);
                                                    if ( (!( (( LA(1) == EOF )) )) )
                                                    {
                                                        alt20=1;
                                                    }

                                                }
                                        }
                                    break;
                                case '\t':
                                case ' ':
                                case '!':
                                case '$':
                                case '%':
                                case '&':
                                case '(':
                                case ')':
                                case '*':
                                case '+':
                                case ',':
                                case '-':
                                case '.':
                                case '/':
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case ':':
                                case ';':
                                case '<':
                                case '=':
                                case '>':
                                case '?':
                                case '@':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'G':
                                case 'H':
                                case 'I':
                                case 'J':
                                case 'K':
                                case 'L':
                                case 'M':
                                case 'N':
                                case 'O':
                                case 'P':
                                case 'Q':
                                case 'R':
                                case 'S':
                                case 'T':
                                case 'U':
                                case 'V':
                                case 'W':
                                case 'X':
                                case 'Y':
                                case 'Z':
                                case '[':
                                case '\\':
                                case ']':
                                case '^':
                                case '_':
                                case '`':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'g':
                                case 'h':
                                case 'i':
                                case 'j':
                                case 'k':
                                case 'l':
                                case 'm':
                                case 'n':
                                case 'o':
                                case 'p':
                                case 'q':
                                case 'r':
                                case 's':
                                case 't':
                                case 'u':
                                case 'v':
                                case 'w':
                                case 'x':
                                case 'y':
                                case 'z':
                                case '{':
                                case '|':
                                case '}':
                                case '~':
                                        {
                                                alt20=1;
                                        }
                                    break;
                                case '\'':
                                        {
                                                alt20=2;
                                        }
                                    break;
                                case '"':
                                        {
                                                alt20=3;
                                        }
                                    break;

                                }

                                switch (alt20)
                                {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:13: ANY_PRINT_CHAR
                                    {
                                        /* 308:13: ANY_PRINT_CHAR */
                                        mANY_PRINT_CHAR(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;
                                case 2:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:30: SINGLE_QUOTE
                                    {
                                        /* 308:30: SINGLE_QUOTE */
                                        mSINGLE_QUOTE(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;
                                case 3:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:308:45: DOUBLE_QUOTE
                                    {
                                        /* 308:45: DOUBLE_QUOTE */
                                        mDOUBLE_QUOTE(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;

                                default:
                                    goto loop20;        /* break out of the loop */
                                    break;
                                }
                            }
                            loop20: ; /* Jump out to here if this rule does not match */


                            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:309:7: ( EOL | {...}?)
                            {
                                int alt21=2;
                                switch ( LA(1) )
                                {
                                case '\n':
                                case '\r':
                                        {
                                                alt21=1;
                                        }
                                    break;

                                default:
                                    alt21=2;}

                                switch (alt21)
                                {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:309:9: EOL
                                    {
                                        /* 309:9: EOL */
                                        mEOL(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;
                                case 2:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:309:15: {...}?
                                    {
                                        if ( !(( LA(1) == EOF )) )
                                        {
                                            if (BACKTRACKING>0)
                                            {
                                                FAILEDFLAG = ANTLR3_TRUE;
                                                return ;
                                            }
                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                                                EXCEPTION->message      = (void *)" LA(1) == EOF ";
                                                EXCEPTION->ruleName      = (void *)"COMMENTS";


                                        }

                                    }
                                    break;

                                }
                            }

                        }
                        break;

                    default:

                        if ( cnt22 >= 1 )
                        {
                            goto loop22;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleCOMMENTSEx;
                }
                cnt22++;
                }
                loop22: ;       /* Jump to here if this rule does not match */
            }

        }

        if ( BACKTRACKING==0 )
        {
             LEXSTATE->channel = HIDDEN;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTSEx; /* Prevent compiler warnings */
    ruleCOMMENTSEx: ;

}
// $ANTLR end COMMENTS

//   Comes from: 322:2: ( NON_BLANK_CHAR_ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NON_BLANK_CHAR
 *
 * Looks to match the characters the constitute the token NON_BLANK_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNON_BLANK_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = NON_BLANK_CHAR;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:322:2: ( NON_BLANK_CHAR_ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:322:4: NON_BLANK_CHAR_
    {
        /* 322:4: NON_BLANK_CHAR_ */
        mNON_BLANK_CHAR_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleNON_BLANK_CHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNON_BLANK_CHAREx; /* Prevent compiler warnings */
    ruleNON_BLANK_CHAREx: ;

}
// $ANTLR end NON_BLANK_CHAR

//   Comes from: 325:2: ( ( '\\t' | ' ' | EOL | '\\u000C' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = WHITESPACE;


    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:2: ( ( '\\t' | ' ' | EOL | '\\u000C' )+ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:5: ( '\\t' | ' ' | EOL | '\\u000C' )+
    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:5: ( '\\t' | ' ' | EOL | '\\u000C' )+
        {
            int cnt23=0;

            for (;;)
            {
                int alt23=5;
                switch ( LA(1) )
                {
                case '\t':
                        {
                                alt23=1;
                        }
                    break;
                case ' ':
                        {
                                alt23=2;
                        }
                    break;
                case '\n':
                case '\r':
                        {
                                alt23=3;
                        }
                    break;
                case '\f':
                        {
                                alt23=4;
                        }
                    break;

                }

                switch (alt23)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:7: '\\t'
                        {
                            MATCHC('\t');
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;
                    case 2:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:14: ' '
                        {
                            MATCHC(' ');
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;
                    case 3:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:20: EOL
                        {
                            /* 325:20: EOL */
                            mEOL(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;
                    case 4:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:325:26: '\\u000C'
                        {
                            MATCHC(0x000C);
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt23 >= 1 )
                        {
                            goto loop23;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleWHITESPACEEx;
                }
                cnt23++;
            }
            loop23: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pcifLexer ctx)
{
    {
        //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:8: ( T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | TAG | SEMI_COLON_TEXT_FIELD | LOOP_ | GLOBAL_ | STOP_ | DATA_BLOCK_HEADING | SAVE_FRAME_HEADING | SAVE | DIGIT | EXPONENT | CHAR_STRING | COMMENTS | NON_BLANK_CHAR | WHITESPACE )

        ANTLR3_UINT32 alt24;

        alt24=20;

        alt24 = cdfa24.predict(ctx, RECOGNIZER, ISTREAM, &cdfa24);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt24)
        {
        case 1:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:10: T__30
            {
                /* 1:10: T__30 */
                mT__30(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:16: T__31
            {
                /* 1:16: T__31 */
                mT__31(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:22: T__32
            {
                /* 1:22: T__32 */
                mT__32(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:28: T__33
            {
                /* 1:28: T__33 */
                mT__33(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:34: T__34
            {
                /* 1:34: T__34 */
                mT__34(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:40: T__35
            {
                /* 1:40: T__35 */
                mT__35(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:46: TAG
            {
                /* 1:46: TAG */
                mTAG(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:50: SEMI_COLON_TEXT_FIELD
            {
                /* 1:50: SEMI_COLON_TEXT_FIELD */
                mSEMI_COLON_TEXT_FIELD(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:72: LOOP_
            {
                /* 1:72: LOOP_ */
                mLOOP_(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 10:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:78: GLOBAL_
            {
                /* 1:78: GLOBAL_ */
                mGLOBAL_(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 11:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:86: STOP_
            {
                /* 1:86: STOP_ */
                mSTOP_(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 12:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:92: DATA_BLOCK_HEADING
            {
                /* 1:92: DATA_BLOCK_HEADING */
                mDATA_BLOCK_HEADING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 13:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:111: SAVE_FRAME_HEADING
            {
                /* 1:111: SAVE_FRAME_HEADING */
                mSAVE_FRAME_HEADING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 14:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:130: SAVE
            {
                /* 1:130: SAVE */
                mSAVE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 15:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:135: DIGIT
            {
                /* 1:135: DIGIT */
                mDIGIT(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 16:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:141: EXPONENT
            {
                /* 1:141: EXPONENT */
                mEXPONENT(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 17:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:150: CHAR_STRING
            {
                /* 1:150: CHAR_STRING */
                mCHAR_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 18:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:162: COMMENTS
            {
                /* 1:162: COMMENTS */
                mCOMMENTS(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 19:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:171: NON_BLANK_CHAR
            {
                /* 1:171: NON_BLANK_CHAR */
                mNON_BLANK_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 20:
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:1:186: WHITESPACE
            {
                /* 1:186: WHITESPACE */
                mWHITESPACE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1_cif
static void synpred1_cif_fragment(pcifLexer ctx )
{
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:7: ( SINGLE_QUOTE NON_BLANK_CHAR_ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:277:8: SINGLE_QUOTE NON_BLANK_CHAR_
    {
        /* 277:8: SINGLE_QUOTE NON_BLANK_CHAR_ */
        mSINGLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 277:8: SINGLE_QUOTE NON_BLANK_CHAR_ */
        mNON_BLANK_CHAR_(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_cifEx; /* Prevent compiler warnings */
rulesynpred1_cifEx: ;

}
// $ANTLR end synpred1_cif

// $ANTLR start synpred2_cif
static void synpred2_cif_fragment(pcifLexer ctx )
{
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:7: ( DOUBLE_QUOTE NON_BLANK_CHAR_ )
    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:283:8: DOUBLE_QUOTE NON_BLANK_CHAR_
    {
        /* 283:8: DOUBLE_QUOTE NON_BLANK_CHAR_ */
        mDOUBLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 283:8: DOUBLE_QUOTE NON_BLANK_CHAR_ */
        mNON_BLANK_CHAR_(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred2_cifEx; /* Prevent compiler warnings */
rulesynpred2_cifEx: ;

}
// $ANTLR end synpred2_cif

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_cif(pcifLexer ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start       = MARK();
    synpred1_cif_fragment(ctx);     // can never throw exception
    success     = !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG  = ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_cif(pcifLexer ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start       = MARK();
    synpred2_cif_fragment(ctx);     // can never throw exception
    success     = !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG  = ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
